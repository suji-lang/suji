// Build script for suji-stdlib
// Generates std_sources_map.rs containing embedded SUJI standard library sources

use std::fs;
use std::path::{Path, PathBuf};

fn main() {
    let std_dir = Path::new("src/std");
    let out_file = Path::new("src/runtime/builtins/std_sources_map.rs");

    // Emit rerun trigger
    println!("cargo:rerun-if-changed=src/std");

    // Collect all .si files recursively
    let mut si_files = Vec::new();
    collect_si_files(std_dir, std_dir, &mut si_files);

    // Generate Rust source
    let mut output = String::new();
    output.push_str("// This file is @generated by build.rs\n");
    output.push_str("// DO NOT EDIT MANUALLY\n\n");
    output.push_str("#![allow(clippy::all)]\n");
    output.push_str("#![cfg_attr(rustfmt, rustfmt_skip)]\n\n");
    output.push_str("use std::collections::HashMap;\n");
    output.push_str("use std::path::PathBuf;\n\n");
    output.push_str("pub fn get_std_sources() -> HashMap<PathBuf, &'static str> {\n");
    output.push_str("    let mut map = HashMap::new();\n");

    for (rel_path, abs_path) in si_files {
        // rel_path is relative to std/ (e.g., "io.si" or "subdir/helper.si")
        // abs_path is relative to crate root for include_str (e.g., "src/std/io.si")
        output.push_str(&format!(
            "    map.insert(PathBuf::from(\"{}\"), include_str!(\"../../{}\"));\n",
            rel_path.display(),
            abs_path.display()
        ));
    }

    output.push_str("    map\n");
    output.push_str("}\n");

    // Write output
    fs::write(out_file, output).expect("Failed to write std_sources_map.rs");
}

fn collect_si_files(base: &Path, current: &Path, out: &mut Vec<(PathBuf, PathBuf)>) {
    if !current.is_dir() {
        return;
    }
    for entry in fs::read_dir(current).expect("Failed to read directory") {
        let entry = entry.expect("Failed to read entry");
        let path = entry.path();
        if path.is_dir() {
            collect_si_files(base, &path, out);
        } else if path.extension().and_then(|s| s.to_str()) == Some("si") {
            let rel = path.strip_prefix(base).expect("Path must be under base");
            let abs = path.strip_prefix("src/").expect("Path must be under src/");
            out.push((rel.to_path_buf(), abs.to_path_buf()));
        }
    }
}
